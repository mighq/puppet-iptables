# generated by mighq/iptables puppet module, do not edit manually
<%-
#require 'pp'
#STDERR.puts PP.pp(@data, "")
#
# TODO: do not generate chains, which are empty and not referenced
#       support param to force even empty chains
-%>
<%-
fwdata = @data['v4']

tables = fwdata.keys.sort
tables.each { |table|
-%>
*<%= table %>
<%-
chains = fwdata[table].keys.sort
chains.each { |chain|
  chdata = fwdata[table][chain]

  # check, if chain was defined by resource, or just created by adding rules
  if not chdata.has_key? 'defined' then
    raise sprintf "You did not define chain '%s:%s' with iptables::chain::*. Cannot add rules to non-existent chain.", table, chain
  end
-%>
:<%= chain %> <% if chdata.has_key? 'policy' then %><%= chdata['policy'] %><% else %>-<% end %> [0:0]
<%- } -%>
<%-
chains.each { |chain|
  chdata = fwdata[table][chain]

    (chdata['type'] == 'builtin'   and chdata['jumps'].length > 0) \
      or \
    (chdata['type'] == 'open'      and chdata['rules'].length > 0) \
      or \
    (chdata['type'] == 'immutable' and chdata['rules_final'].length > 0) \

  # prepare & print rules for chain

  if    chdata['type'] == 'open' then
    # rules are in hash (command => comment) format
    rules = chdata['rules']

    # always sort by key, so we get consistent results each run
    rules = rules.sort

    # header
    if chdata['rules'].length > 0 then
-%>
<%=   sprintf "### rules for '%s:%s' (open)", table, chain %>
<%-
      if chdata.has_key? 'comment' and chdata['comment'].length > 0 then %><%= "# " + chdata['comment'] + "\n" %><% end
    end

    # print all rules in immutable chain
    rules.each { |rule, comment| -%>
<%=   "# " + comment %>
<%=   "-A " + chain + " " + rule %>
<%-
    }

  elsif chdata['type'] == 'builtin' then
    # check if we did not mix builtin & open
    if chdata.has_key? 'rules' then
      raise sprintf "You are trying to dynamically add %d rule(s) to builtin chain '%s:%s'", chdata['rules'].length, table, chain
    end

    # validate jump items
    jumps = []
    chdata['jumps'].each { |jumpspec|
      (jump,extra) = jumpspec.split('|')
      # check if jump target is known
      if not chains.include? jump then
        raise sprintf "You are trying to reference non-existing chain '%s' from builtin chain '%s:%s'", jump, table, chain
      end

      # only use jump, if there is anything to evaluate in target chain
      # ignore otherwise
      if \
        (fwdata[table][jump]['type'] == 'open'      and fwdata[table][jump]['rules'].length > 0) \
          or
        (fwdata[table][jump]['type'] == 'immutable' and fwdata[table][jump]['rules_final'].length > 0) \
          or
        (fwdata[table][jump]['type'] == 'unmanaged') \
      then
        jumps.push(Hash["jump" => jump, "extra" => extra])
      end
    }

    # header
    if jumps.length > 0 then
-%>
<%=   sprintf "### jumps for '%s:%s' (builtin)", table, chain %>
<%-
      if chdata.has_key? 'comment' and chdata['comment'].length > 0 then %><%= "# " + chdata['comment'] + "\n" %><% end
    end

    # print all rules in immutable chain
    jumps.each { |jumpspec|
-%>
<%=   "-A " + chain %><%- if not jumpspec["extra"].nil? -%> <%= jumpspec["extra"] %><%- end -%><%= " -j " + jumpspec["jump"] %>
<%-
    }
   
  elsif chdata['type'] == 'immutable' then
    # rules are just as an array of commands
    rules = chdata['rules_final']

    # header
    if rules.length > 0 then
-%>
<%=   sprintf "### rules for '%s:%s' (immutable)", table, chain %>
<%-
      if chdata.has_key? 'comment' and chdata['comment'].length > 0 then %><%= "# " + chdata['comment'] + "\n" %><% end
    end

    # check if we did not mix immutable & open
    if chdata.has_key? 'rules' then
      raise sprintf "You are trying to dynamically add %d rule(s) to immutable chain '%s:%s'", chdata['rules'].length, table, chain
    end

    # print all rules in immutable chain
    rules.each { |rule| -%>
<%=   "-A " + chain + " " + rule %>
<%- }
  end
-%>
<%- } -%>
COMMIT
<%- } -%>
